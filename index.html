<!DOCTYPE html>
<html>
<head>
    <title>AR with Marker</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.rawgit.com/ngokevin/kframe/master/components/gesture-handler/dist/gesture-handler.min.js"></script>
</head>
<body style='margin: 0; overflow: hidden;'>
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
        <a-marker type='pattern' url='marker.patt' emitevents='true'>
            <a-entity id='marker-root' position='0 0 0'>
                <a-image id='ar-image' src='image.png' position='0 0 0.5' rotation='0 0 0' scale='3 3 3' gesture-handler></a-image>
            </a-entity>
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: { default: true },
                rotationFactor: { default: 5 },
                minScale: { default: 1 },
                maxScale: { default: 5 },
            },
            init: function () {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                this.isVisible = false;
                this.el.sceneEl.addEventListener('markerFound', (e) => {
                    if (e.target === this.el) {
                        this.isVisible = true;
                    }
                });
                this.el.sceneEl.addEventListener('markerLost', (e) => {
                    if (e.target === this.el) {
                        this.isVisible = false;
                    }
                });
            },
            update: function () {
                if (this.data.enabled) {
                    this.addEventListeners();
                } else {
                    this.removeEventListeners();
                }
            },
            remove: function () {
                this.removeEventListeners();
            },
            tick: function () {},
            addEventListeners: function () {
                this.el.sceneEl.canvas.addEventListener('touchstart', this.handleTouchStart);
                this.el.sceneEl.canvas.addEventListener('touchmove', this.handleTouchMove);
            },
            removeEventListeners: function () {
                this.el.sceneEl.canvas.removeEventListener('touchstart', this.handleTouchStart);
                this.el.sceneEl.canvas.removeEventListener('touchmove', this.handleTouchMove);
            },
            handleTouchStart: function (event) {
                if (event.touches.length === 2) {
                    this.initialDistance = this.getDistance(event.touches[0], event.touches[1]);
                } else if (event.touches.length === 1) {
                    this.initialTouch = event.touches[0];
                }
            },
            handleTouchMove: function (event) {
                if (event.touches.length === 2 && this.initialDistance) {
                    let currentDistance = this.getDistance(event.touches[0], event.touches[1]);
                    let scaleFactor = currentDistance / this.initialDistance;
                    scaleFactor = Math.min(Math.max(scaleFactor, this.data.minScale), this.data.maxScale);
                    this.el.object3D.scale.set(scaleFactor, scaleFactor, scaleFactor);
                } else if (event.touches.length === 1 && this.initialTouch) {
                    let deltaX = event.touches[0].pageX - this.initialTouch.pageX;
                    let deltaY = event.touches[0].pageY - this.initialTouch.pageY;
                    this.el.object3D.rotation.y += deltaX * this.data.rotationFactor / 1000;
                    this.el.object3D.rotation.x -= deltaY * this.data.rotationFactor / 1000;
                    this.initialTouch = event.touches[0];
                }
            },
            getDistance: function (touch1, touch2) {
                return Math.sqrt(Math.pow(touch1.pageX - touch2.pageX, 2) + Math.pow(touch1.pageY - touch2.pageY, 2));
            }
        });

        AFRAME.registerComponent('markerhandler', {
            init: function () {
                const marker = this.el;
                const arImage = document.querySelector('#ar-image');
                marker.addEventListener('markerFound', () => {
                    arImage.object3D.visible = true;
                });
                marker.addEventListener('markerLost', () => {
                    arImage.object3D.visible = true; // 画像を表示したままにする
                });
            }
        });

        // Register markerhandler component to the marker
        document.querySelector('a-marker').setAttribute('markerhandler', '');
    </script>
</body>
</html>
